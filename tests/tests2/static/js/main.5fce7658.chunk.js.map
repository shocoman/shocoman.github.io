{"version":3,"sources":["App.js","index.js"],"names":["id_count","getNodeKey","node","treeIndex","id","App","newNode","title","prob","temporary","subtitle","e","toPrecision","code","useState","treeData","setTreeData","style","height","margin","onClick","prevTree","next","push","onChange","onMoveNode","params","nextParentNode","prevPath","prevTreeIndex","nextPath","nextTreeIndex","length","p","n","walk","ignoreCollapsed","callback","children","reduce","acc","curr","mywalk","i","console","log","canDrop","prevParent","nextParent","ReactDOM","render","document","getElementById"],"mappings":"2NAKIA,G,MAAW,GAEf,SAASC,EAAT,GAAwC,IAAnBC,EAAkB,EAAlBA,KAAkB,EAAZC,UAEvB,OAAOD,EAAKE,GAoBD,SAASC,IAEpB,IAAMC,EAAU,SAACC,EAAOC,GAAR,IAAcC,EAAd,8DAAqC,CACjDF,QAAOE,YAAWD,OAClBE,SAAU,SAACC,GAAD,MAAO,cAAgBA,EAAET,KAAKM,KAAKI,YAAY,GAAK,WAAaD,EAAET,KAAKW,MAClFT,GAAIJ,IAAYa,KAAM,MALA,EAQMC,mBAAS,CACrCR,EAAQ,IAAK,IACbA,EAAQ,IAAK,IACbA,EAAQ,IAAK,IACbA,EAAQ,IAAK,IACbA,EAAQ,IAAK,MAbS,mBAQnBS,EARmB,KAQTC,EARS,KAkI1B,OACI,sBAAKC,MAAO,CAACC,OAAQ,KAArB,UACI,wBAAQD,MAAO,CAACE,OAAQ,QAASC,QAVzB,SAACT,GACbK,GAAY,SAAAK,GACR,IAAIC,EAAI,YAAOD,GAEf,OADAC,EAAKC,KAAKjB,EAAQ,MAAO,GAAK,IACvBgB,MAMP,0BACA,cAAC,IAAD,CACIP,SAAUA,EACVS,SAAU,SAAAT,GAAQ,OAAIC,EAAYD,IAClCU,WAnGO,SAACC,GAAY,IACrBX,EAAoFW,EAApFX,SAAgBY,GAAoED,EAA1ExB,KAA0EwB,EAApEC,gBAAgBC,EAAoDF,EAApDE,SAAoDF,EAA1CG,cAA0CH,EAA3BI,SAA2BJ,EAAjBK,cAG1E,GAAIH,EAASI,QAAU,EAAG,CACtB,IAAIC,EAAIL,EAASA,EAASI,OAAS,GAC/BE,EAAI,KACRC,YAAK,CACDpB,WACAd,aACAmC,iBAAiB,EACjBC,SAAU,YAAa,IAAXnC,EAAU,EAAVA,KACJA,EAAKE,KAAO6B,IAAGC,EAAIhC,MAGtB,MAALgC,IACAA,EAAE1B,KAAO0B,EAAEI,SAASC,QAAO,SAACC,EAAKC,GAAN,OAAeD,EAAMC,EAAKjC,OAAM,GAC3D0B,EAAE3B,MAAQ,KAAO2B,EAAEI,SAASC,QAAO,SAACC,EAAKC,GAAN,OAAeD,EAAMC,EAAKlC,MAAQ,MAAK,KAAO,MAIzF,GAAKoB,GAAmBA,EAAelB,UAAvC,CACAkB,EAAenB,KAAOmB,EAAeW,SAASC,QAAO,SAACC,EAAKC,GAAN,OAAeD,EAAMC,EAAKjC,OAAM,GACrFmB,EAAepB,MAAQ,KAAOoB,EAAeW,SAASC,QAAO,SAACC,EAAKC,GAAN,OAAeD,EAAMC,EAAKlC,MAAQ,MAAK,KAAO,KAyC3G,IAvCA,IAqBMmC,EAAS,SAATA,EAAUxC,EAAMW,GAGlBX,EAAKW,KAAOA,EACRX,EAAKoC,UAAYpC,EAAKoC,SAASN,QAAU,IAKzCU,EAAOxC,EAAKoC,SAAS,GAAIzB,EAAO,KAC5BX,EAAKoC,SAASN,QAAU,GACxBU,EAAOxC,EAAKoC,SAAS,GAAIzB,EAAO,OAOnC8B,EAAI,EAAGA,EAAI5B,EAASiB,SAAUW,EACnCD,EAAO3B,EAAS4B,GAAI,IAgBxBC,QAAQC,IAAI9B,KAoBJ+B,QA/GI,SAACpB,GAC4EA,EAAlFxB,KAAkFwB,EAA5EE,SAA4EF,EAAlEqB,WAAkErB,EAAtDG,cAAsDH,EAAvCI,SADzB,IACmCkB,EAA6BtB,EAA7BsB,WAA6BtB,EAAjBK,cAGxE,QAAIiB,KAAgBA,EAAWvC,WAAauC,EAAWV,SAASN,OAAS,KA4GjE/B,WAAYA,OCnK5BgD,IAASC,OACL,cAAC7C,EAAD,IACF8C,SAASC,eAAe,W","file":"static/js/main.5fce7658.chunk.js","sourcesContent":["import React, {Component, useState} from 'react';\nimport SortableTree, {changeNodeAtPath, find, getNodeAtPath, insertNode, walk} from 'react-sortable-tree';\nimport 'react-sortable-tree/style.css'; // This only needs to be imported once in your app\n\n\nlet id_count = 0;\n\nfunction getNodeKey({node, treeIndex}) {\n    // return node.title + '_' + treeIndex.toString();\n    return node.id;\n}\n\nfunction getParent(childNode, treeData) {\n    let parent = null;\n\n    walk({\n        treeData,\n        getNodeKey,\n        ignoreCollapsed: false,\n        callback: ({node}) => {\n            if (find(node.children, {id: getNodeKey(childNode)})) {\n                parent = node;\n            }\n        },\n    });\n\n    return parent;\n}\n\nexport default function App() {\n\n    const newNode = (title, prob, temporary = false) => ({\n        title, temporary, prob,\n        subtitle: (e) => \"Frequency: \" + e.node.prob.toPrecision(2) + '; Code: ' + e.node.code,\n        id: id_count++, code: '_'\n    });\n\n    const [treeData, setTreeData] = useState([\n        newNode('A', 0.3),\n        newNode('B', 0.3),\n        newNode('C', 0.1),\n        newNode('D', 0.2),\n        newNode('E', 0.1),\n    ]);\n\n    // const canDrag = (params) => {\n    //     // console.log(params);\n    //\n    //     const {node, path, treeIndex, lowerSiblingCounts} = params;\n    //     if (params.parentNode == null) {\n    //         return true;\n    //     }\n    //\n    //     return true;\n    // };\n\n    const canDrop = (params) => {\n        const {node, prevPath, prevParent, prevTreeIndex, nextPath, nextParent, nextTreeIndex} = params;\n\n\n        if (nextParent && (!nextParent.temporary || nextParent.children.length > 2)) return false;\n\n\n        return true;\n    };\n\n    const onMoveNode = (params) => {\n        const {treeData, node, nextParentNode, prevPath, prevTreeIndex, nextPath, nextTreeIndex} = params;\n\n\n        if (prevPath.length >= 2) {\n            let p = prevPath[prevPath.length - 2];\n            let n = null;\n            walk({\n                treeData,\n                getNodeKey,\n                ignoreCollapsed: false,\n                callback: ({node}) => {\n                    if (node.id === p) n = node;\n                },\n            });\n            if (n != null) {\n                n.prob = n.children.reduce((acc, curr) => acc + curr.prob, 0);\n                n.title = '{ ' + n.children.reduce((acc, curr) => acc + curr.title + ' ', ' ') + ' }';\n            }\n        }\n\n        if (!nextParentNode || !nextParentNode.temporary) return;\n        nextParentNode.prob = nextParentNode.children.reduce((acc, curr) => acc + curr.prob, 0);\n        nextParentNode.title = '{ ' + nextParentNode.children.reduce((acc, curr) => acc + curr.title + ' ', ' ') + ' }';\n\n        let code = '';\n        const next = () => {\n            code = code === '' ? '0' : code[code.length - 1] === '0' ? code.substr(0, code.length - 1) + \"1\" : code + '0';\n        };\n\n        const prev = () => {\n            code = code.substr(0, code.length - 1);\n        };\n\n        // walk({\n        //     treeData,\n        //     getNodeKey,\n        //     ignoreCollapsed: false,\n        //     callback: ({ node }) => {\n        //         node.code = code;\n        //         // if (!node.temporary)\n        //             next();\n        //     },\n        // });\n\n\n        const mywalk = (node, code) => {\n            // callback1();\n\n            node.code = code;\n            if (node.children && node.children.length >= 1) {\n                // for (let c of node.children) {\n                //     mywalk(c, callback1, callback2);\n                // }\n\n                mywalk(node.children[0], code + '0');\n                if (node.children.length >= 2) {\n                    mywalk(node.children[1], code + '1');\n                }\n            }\n\n            // callback2();\n        };\n\n        for (let i = 0; i < treeData.length; ++i)\n            mywalk(treeData[i], ''\n            );\n\n        // let queue = [...treeData];\n        // while (queue.length > 0) {\n        //     let el = queue.shift();\n        //     if (el.children)\n        //         for (let c of el.children) {\n        //             queue.push(c);\n        //         }\n        //\n        //         el.code = code;\n        //         // if (!node.temporary)\n        //         next();\n        // }\n\n        console.log(treeData);\n\n    };\n\n    const onClick = (e) => {\n        setTreeData(prevTree => {\n            let next = [...prevTree];\n            next.push(newNode('TMP', 0.0, true));\n            return next;\n        })\n    };\n\n    return (\n        <div style={{height: 600}}>\n            <button style={{margin: '20px'}} onClick={onClick}>Add new node</button>\n            <SortableTree\n                treeData={treeData}\n                onChange={treeData => setTreeData(treeData)}\n                onMoveNode={onMoveNode}\n                // canDrag={canDrag}\n                canDrop={canDrop}\n                getNodeKey={getNodeKey}\n            />\n        </div>\n    );\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}