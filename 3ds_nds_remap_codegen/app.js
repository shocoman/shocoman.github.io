const codeHexString = "10008FE204109FE5010080E010FF2FE1480400000000A0E10230A0E3013043E2000053E3FCFFFFCA1EFF2FE1F0412DE90370A0E17330A0E3DC409FE53830C4E5F4FFFFEB7730A0E30880A0E33830C4E5F0FFFFEB0050D0E5A563A0E1743086E33830C4E5766086E3EAFFFFEB3860C4E5E8FFFFEB8550A0E1018058E2FF5005E2F4FFFF1A020051E30C00001A0850A0E30110D0E5A103A0E1743080E33830C4E5760080E3DBFFFFEB3800C4E5D9FFFFEB8110A0E1015055E2FF1001E2F4FFFF1A000057E30F00000A0800A0E30010A0E36450A0E36660A0E33850C4E5CDFFFFEB3860C4E5CBFFFFEB3830D4E58110A0E1010013E3FF1001E201108113010050E2F4FFFF1A0010C2E5C2FFFFEB6230A0E33830C4E5F041BDE8BEFFFFEA000100046E30A0E307402DE90430CDE50030A0E30500CDE50320A0E10210A0E304008DE2B9FFFFEB0CD08DE204E09DE41EFF2FE10133A0E38020A0E381CCA0E310109FE5B403D1E1142283E5B4C3C1E1142283E51EFF2FE1000100040133A0E38020A0E3013C83E2142183E5B403C3E11EFF2FE16D30A0E307402DE90630CDE50030A0E30730CDE50130A0E306008DE20310A0E107208DE29CFFFFEB0700DDE50CD08DE204E09DE41EFF2FE10133A0E313402DE90040A0E164009FE5142293E5800012E30400001A010050E2FAFFFF1A8020A0E3142283E50E0000EA8020A0E3142283E56F30A0E30630CDE50030A0E30730CDE50130A0E306008DE20310A0E107208DE281FFFFEB0700DDE5003044E0000073E20300A0E008D08DE21040BDE81EFF2FE1A4781F00B5FFFFEA6C30A0E313402DE90430CDE50030A0E30040A0E10510CDE504008DE20320A0E10210A0E36EFFFFEB0400A0E108D08DE21040BDE8A7FFFFEA10402DE9A5FFFFEB8000A0E31040BDE8CCFFFFEA10402DE9EAFFFFEB8000A0E31040BDE8C7FFFFEA10402DE9FE00A0E39AFFFFEB0000A0E31040BDE8C1FFFFEA8200A0E395FFFFEA70402DE90050A0E10140A0E14100A0E3FF1001E2ECFFFFEB000050E31100000A2414A0E18100A0E3FF1001E2E6FFFFEB000050E30B00000A2418A0E18100A0E3FF1001E2E0FFFFEB000050E30500000A241CA0E18100A0E3DBFFFFEB000050E3044085100700001A0000A0E37040BDE81EFF2FE18100A0E30110D5E4D2FFFFEB000050E3F7FFFF0A040055E1F8FFFF1A8300A0E36FFFFFEB8200A0E397FFFFEB4200A0E37040BDE8C2FFFFEA0010A0E14400A0E3C4FFFFEA0133A0E30020A0E3F0412DE9086293E5082283E56DFFFFEB0A50A0E30040A0E10100A0E35DFFFFEB8200A0E385FFFFEB000050E30900001A015055E2F7FFFF1A0133A0E38020A0E3142283E538209FE5B443C2E1086283E5F041BDE81EFF2FE10A50A0E324709FE507708FE0CD1FA0E30700A0E1B3FFFFEB000050E3EFFFFF1A015055E2F8FFFF1AECFFFFEA0001000400010000F0412DE90030A0E30143A0E3087294E5083284E50060A0E147FFFFEBFF1006E20050A0E14400A0E381FFFFEB8030A0E3143284E50C309FE5B453C3E1087284E5F041BDE81EFF2FE10001000410402DE978309FE503308FE074209FE5003093E502409FE74D2F83E2022082E2020054E10600000A040053E10600001ABAFFFFEB50309FE5014084E203308FE0004083E51040BDE81EFF2FE1C82083E2020054E10100A0030700000AFA2083E2020054E10200A0030300000A4B3F83E2030054E1EEFFFF1A0300A0E3CCFFFFEBEBFFFFEAB8030000A803000080030000FE5F2DE9010000EBFE9FBDE800000000013040E2020053E30300008A10402DE9800000EB0000A0E31080BDE80000A0E31EFF2FE1F7B5D21A01920022150006000898441E0C404819875CBC46B75CBC4504D10132934203D1002C05D00022013501988542EFD10020FEBDFFFFF7B50227A02280210E4D10232800009792024903FFF7D8FF002811D001240A4E20433060A022280080210E231030009792024903FFF7C8FF002801D004437460F7BDC046381220003413200030B585B0FFF7D6FF114C2368002B1DD00225A02280210E230E48009592024903FFF7ACFF002811D0436B0E211A0046321570542247331A700F23A8326B441A70FB3A0092002264681000A04705B030BD341320005612200007B50223A0228021009305480A3392024903FFF787FF002800D03E300EBDC0466412200013B50223A022802100930A480C3392024903FFF775FF084CA060002801D1002016BDFFF7DBFFE0600028F8D0FFF7AAFF0120F5E7701220003413200073B56B46264C073322781870002A3ED01A78012A23D1FFF7D5FF2070002836D0204DAB689A0702D000221A80023300221D4CA05C991801320870B02AF9D119002868AF3AAC3102430A609C1EB426201C311C7ADF154BEC680225238014E01A78022A15D1F02204250E4B1202D9689B688C1C043B1B1B5802400D10430C4A5B0813439BB248808B80201C291C7ADF73BD1B78032BFBD1034BDC68064BDCE7C04630132000341320007E12200001E0FFFF00F8FFFF4C40000000C09FE51CFF2FE17111200000000000FFB581B014460D461E460A9F01981146FFB581B0144605461E460A9F029970B506460B4C88000D183046615D010E0843B0433440204384B2FEB5012132482F4C00912F4DC168FFB550B400F028F80203234B01201988C9430905090D114300231A0007A489B20D001D41054202D05D00655B2A4301330E2BF5D150BC00F025F8FFBD0100020004000800100020004000800000010002000400080000000040B56E46032400230E2269460C39A1438D4610B40F480D2801DA002004E080476A4650794007800FB54640BD064B07491980044BE44334402243D2431A8070470060C41E1211C41E1011C41EFF0F00000071C41E00000000FFFF01FFFFFF00000000E803000000000000";
const keymapTableOffset = 0x7AA;
const nubInitCallOffset = 0x650;
const launchDelayOffset = 0x828;


let codeByteArray = null;

const defaultControlsTable = [
  0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
  0x0200, 0x0400, 0x0800, 0, 0,
];

const currentControlsTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

const keyNames3DS = [
  "A",
  "B",
  "Select",
  "Start",
  "Right",
  "Left",
  "Up",
  "Down",
  "R",
  "L",
  "X",
  "Y",
  "ZR (New3DS)",
  "ZL (New3DS)",
];

const keyNamesNDS = [
  "A",
  "B",
  "Select",
  "Start",
  "Right",
  "Left",
  "Up",
  "Down",
  "R",
  "L",
  "X",
  "Y",
];

function hexToBytes(hex) {
  let bytes = [];
  for (let c = 0; c < hex.length; c += 2)
    bytes.push(parseInt(hex.substr(c, 2), 16));
  return bytes;
}

function getCodeBytes() {
  if (!Array.isArray(codeByteArray)) {
    codeByteArray = hexToBytes(codeHexString);
  }

  // put back the nub init call (in case the user selected ZL or ZR)
  nubInitCall = codeHexString.substr(nubInitCallOffset * 2, 8);
  half1 = parseInt(nubInitCall.substr(0, 4), 16);
  half2 = parseInt(nubInitCall.substr(4, 4), 16);
  codeByteArray[nubInitCallOffset] = (half1 >> 8) & 0xFF;
  codeByteArray[nubInitCallOffset + 1] = half1 & 0xFF;
  codeByteArray[nubInitCallOffset + 2] = (half2 >> 8) & 0xFF;
  codeByteArray[nubInitCallOffset + 3] = half2 & 0xFF;

  return codeByteArray;
}

function copyTextToClipboard(text) {
  navigator.clipboard.writeText(text).then(
    () => {},
    (err) => {
      console.error("Text copy error: ", err);
    }
  );
}

function getOnesInBinary(num) {
  let binaryString = num.toString(2);
  let onBitIndexes = [];

  for (let i = 0; i < binaryString.length; i++) {
    if (binaryString[i] === "1") {
      onBitIndexes.push(binaryString.length - i - 1);
    }
  }

  return onBitIndexes;
}

function checkboxClicked(row, col, event) {
  const bit = event.target.checked;
  const currVal = currentControlsTable[row];
  const newVal = (currVal & ~(1 << col)) | (bit << col);
  currentControlsTable[row] = newVal;

  regenerateActionReplayCode();
}

function generateTable(rowNames, colNames) {
  let table = document.createElement("table");

  // add column names
  let topleft = document.createElement("td");
  const a = document.createElement("div");
  const b = document.createElement("div");
  topleft.className = 'mytd';
  a.className = "c1";
  a.textContent = "NDS Keys";
  b.className = "c2";
  b.textContent = "3DS Keys";
  topleft.appendChild(a);
  topleft.appendChild(b);

  let row = document.createElement("tr");
  row.appendChild(topleft);
  for (let i = 0; i < colNames.length; i++) {
    let cell = document.createElement("th");
    cell.textContent = colNames[i];
    cell.style = "writing-mode: vertical-rl; text-orientation: mixed;";
    row.appendChild(cell);
  }
  table.appendChild(row);

  for (let i = 0; i < rowNames.length; i++) {
    let row = document.createElement("tr");

    // add row name
    let cell = document.createElement("th");
    cell.textContent = rowNames[i];
    row.appendChild(cell);

    for (let j = 0; j < colNames.length; j++) {
      let cell = document.createElement("td");

      let checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.onchange = (e) => checkboxClicked(i, j, e);

      cell.appendChild(checkbox);
      row.appendChild(cell);
    }

    table.appendChild(row);
  }
  return table;
}

function fillTableWithDefaultValues(currentControlsMode) {
  const defaults = defaultControlsTable;
  for (let i = 0; i < defaults.length; i++) {
    currentControlsMode[i] = defaults[i];
  }
}

function refreshTable(tableElem, rawKeyValues) {
  for (let i = 1; i <= keyNames3DS.length; i++) {
    for (let j = 1; j <= keyNamesNDS.length; j++) {
      const cell = tableElem.rows[i].cells[j];
      let checkbox = cell.querySelector("input");
      checkbox.checked = false;
    }
  }

  for (let i = 0; i < keyNames3DS.length; i++) {
    let currentKey = rawKeyValues[i];
    let keysIndices = getOnesInBinary(currentKey);
    keysIndices.forEach((j) => {
      const cell = tableElem.rows[i + 1].cells[j + 1];
      let checkbox = cell.querySelector("input");
      checkbox.checked = true;
    });
  }

  regenerateActionReplayCode();
}

function ar_code__bulk_write(bin, address, run_code = false) {
  if (bin.length % 8 != 0) {
    bin = bin.concat(Array(8 - (bin.length % 8)).fill(0)); // 8-byte alignment
  }

  const hexify = (num, pad) =>
    num.toString(16).padStart(pad, "0").toUpperCase();

  let code_type = run_code ? "C2000000" : `E${hexify(address, 7)}`;

  let ar_code = `${code_type} ${hexify(bin.length, 8)}\n`;
  for (let i = 0; i < bin.length; i += 8) {
    let nibble0 = bin[i] + (bin[i + 1] << 8);
    let nibble1 = bin[i + 2] + (bin[i + 3] << 8);
    let nibble2 = bin[i + 4] + (bin[i + 5] << 8);
    let nibble3 = bin[i + 6] + (bin[i + 7] << 8);
    const nibbles = [nibble0, nibble1, nibble2, nibble3].map((e) =>
      hexify(e, 4)
    );
    ar_code += `${nibbles[1]}${nibbles[0]} ${nibbles[3]}${nibbles[2]}\n`;
  }

  return ar_code;
}

function regenerateActionReplayCode() {
  // "1XXXXXXX ????YYYY" to write YYYY into XXXXXXXX
  let arCode = "";
  const arCodeTextarea = document.getElementById("ar-code-area");

  const codeBytes = getCodeBytes();

  // patch-in key map
  for (let i = 0; i < keyNames3DS.length; i++) {
    const keyValue = currentControlsTable[i];
    const offset = keymapTableOffset + i * 2;
    codeBytes[offset] = keyValue & 0xff;
    codeBytes[offset + 1] = (keyValue >> 8) & 0xff;
    // arCode += `${keyValue.toString(16).padEnd(4, '0').toUpperCase()}\n`
  }

  const areZlZrUsed =
    currentControlsTable[12] != 0 || currentControlsTable[13] != 0;

  if (!areZlZrUsed) {
    // remove Zl & Zr support if it's not used
    codeByteArray[nubInitCallOffset] = 0;
    codeByteArray[nubInitCallOffset + 1] = 0;
    codeByteArray[nubInitCallOffset + 2] = 0;
    codeByteArray[nubInitCallOffset + 3] = 0;
  }

  arCode += `${ar_code__bulk_write(codeBytes, 0, true)}`;

  arCodeTextarea.value = arCode;
}

function updateLaunchDelay(val) {
  val = parseInt(val) || 1000;
  codeByteArray[launchDelayOffset] = val & 0xFF;
  codeByteArray[launchDelayOffset + 1] = (val >> 8) & 0xFF;
  codeByteArray[launchDelayOffset + 2] = (val >> 16) & 0xFF;
  codeByteArray[launchDelayOffset + 3] = (val >> 24) & 0xFF;
  regenerateActionReplayCode();
}

window.onload = function () {
  fillTableWithDefaultValues(currentControlsTable);

  const controlsTableElem = generateTable(keyNames3DS, keyNamesNDS);
  refreshTable(controlsTableElem, defaultControlsTable);

  const collapseDescr = document.createElement("summary");
  const modeNameElem = document.createElement("b");
  collapseDescr.appendChild(modeNameElem);

  const resetToDefaultBtnElem = document.createElement("button");
  resetToDefaultBtnElem.textContent = "Reset Table to Default";
  resetToDefaultBtnElem.addEventListener("click", (e) => {
    const currVals = currentControlsTable;
    fillTableWithDefaultValues(currVals);
    refreshTable(controlsTableElem, currVals);
    console.log(controlsTableElem);
  });

  const controlModesDiv = document.getElementById("control-modes");
  controlModesDiv.appendChild(resetToDefaultBtnElem);
  controlModesDiv.appendChild(controlsTableElem);

  const copyCodeBtnElem = document.getElementById("copy-btn");
  copyCodeBtnElem.addEventListener("click", () => {
    const arCodeTextArea = document.getElementById("ar-code-area");
    copyTextToClipboard(arCodeTextArea.value);
  });

  const launchDelayTextField = document.getElementById("launch-delay");
  updateLaunchDelay(launchDelayTextField.value);
  launchDelayTextField.addEventListener("change", (event) => {
    updateLaunchDelay(event.target.value);
  });
};
